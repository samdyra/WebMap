{"version":3,"file":"index.js","sources":["../src/types.ts","../src/utils.ts","../src/index.ts"],"sourcesContent":["import {\n  MouseEvent as ReactMouseEvent,\n  MouseEventHandler,\n  TouchEvent as ReactTouchEvent,\n  TouchEventHandler,\n} from 'react';\n\nexport type Coordinates = {\n  x: number;\n  y: number;\n} | null;\n\nexport enum LongPressEventReason {\n  // Triggered when mouse / touch was moved outside initial press area when `cancelOnMovement` is active\n  CANCELED_BY_MOVEMENT = 'canceled-by-movement',\n  // Triggered when released click / tap before long press detection threshold\n  CANCELED_BY_TIMEOUT = 'canceled-by-timeout',\n}\nexport type LongPressEvent<Target = Element> = ReactMouseEvent<Target> | ReactTouchEvent<Target>;\nexport type LongPressCallbackMeta<Context = unknown> = { context?: Context; reason?: LongPressEventReason };\nexport type LongPressCallback<Target = Element, Context = unknown> = (\n  event: LongPressEvent<Target>,\n  meta: LongPressCallbackMeta<Context>\n) => void;\n\nexport enum LongPressDetectEvents {\n  BOTH = 'both',\n  MOUSE = 'mouse',\n  TOUCH = 'touch',\n}\n\nexport type LongPressResult<\n  Target,\n  DetectType extends LongPressDetectEvents = LongPressDetectEvents.BOTH\n> = DetectType extends LongPressDetectEvents.BOTH\n  ? {\n      onMouseDown: MouseEventHandler<Target>;\n      onMouseUp: MouseEventHandler<Target>;\n      onMouseMove: MouseEventHandler<Target>;\n      onMouseLeave: MouseEventHandler<Target>;\n      onTouchStart: TouchEventHandler<Target>;\n      onTouchMove: TouchEventHandler<Target>;\n      onTouchEnd: TouchEventHandler<Target>;\n    }\n  : DetectType extends LongPressDetectEvents.MOUSE\n  ? {\n      onMouseDown: MouseEventHandler<Target>;\n      onMouseUp: MouseEventHandler<Target>;\n      onMouseMove: MouseEventHandler<Target>;\n      onMouseLeave: MouseEventHandler<Target>;\n    }\n  : DetectType extends LongPressDetectEvents.TOUCH\n  ? {\n      onTouchStart: TouchEventHandler<Target>;\n      onTouchMove: TouchEventHandler<Target>;\n      onTouchEnd: TouchEventHandler<Target>;\n    }\n  : never;\nexport type EmptyObject = Record<string, never>;\nexport type CallableContextResult<T, Context> = (context?: Context) => T;\n\nexport interface LongPressOptions<Target = Element, Context = unknown> {\n  threshold?: number;\n  captureEvent?: boolean;\n  detect?: LongPressDetectEvents;\n  filterEvents?: (event: LongPressEvent<Target>) => boolean;\n  cancelOnMovement?: boolean | number;\n  onStart?: LongPressCallback<Target, Context>;\n  onMove?: LongPressCallback<Target, Context>;\n  onFinish?: LongPressCallback<Target, Context>;\n  onCancel?: LongPressCallback<Target, Context>;\n}\n","import { Coordinates, LongPressEvent } from './types';\nimport { MouseEvent as ReactMouseEvent, TouchEvent as ReactTouchEvent } from 'react';\n\nexport function isTouchEvent<Target>(event: LongPressEvent<Target>): event is ReactTouchEvent<Target> {\n  const { nativeEvent } = event;\n  return window.TouchEvent ? nativeEvent instanceof TouchEvent : 'touches' in nativeEvent;\n}\n\nexport function isMouseEvent<Target>(event: LongPressEvent<Target>): event is ReactMouseEvent<Target> {\n  return event.nativeEvent instanceof MouseEvent;\n}\n\nexport function getCurrentPosition<Target>(event: LongPressEvent<Target>): Coordinates {\n  if (isTouchEvent(event)) {\n    return {\n      x: event.touches[0].pageX,\n      y: event.touches[0].pageY,\n    };\n  }\n\n  /* istanbul ignore else */\n  if (isMouseEvent(event)) {\n    return {\n      x: event.pageX,\n      y: event.pageY,\n    };\n  }\n\n  /* istanbul ignore next */\n  return null;\n}\n","import { MouseEventHandler, TouchEventHandler, useCallback, useEffect, useMemo, useRef } from 'react';\nimport {\n  CallableContextResult,\n  Coordinates,\n  EmptyObject,\n  LongPressCallback,\n  LongPressCallbackMeta,\n  LongPressDetectEvents,\n  LongPressEvent,\n  LongPressEventReason,\n  LongPressOptions,\n  LongPressResult,\n} from './types';\nimport { getCurrentPosition, isMouseEvent, isTouchEvent } from './utils';\n\nexport function useLongPress<Target = Element, Context = unknown>(\n  callback: null,\n  options?: LongPressOptions<Target>\n): CallableContextResult<EmptyObject, Context>;\nexport function useLongPress<\n  Target = Element,\n  Callback extends LongPressCallback<Target, Context> = LongPressCallback<Target>,\n  Context = unknown\n>(callback: Callback, options?: LongPressOptions<Target>): CallableContextResult<LongPressResult<Target>, Context>;\nexport function useLongPress<\n  Target = Element,\n  Callback extends LongPressCallback<Target, Context> = LongPressCallback<Target>,\n  Context = unknown\n>(\n  callback: Callback | null,\n  options?: LongPressOptions<Target>\n): CallableContextResult<LongPressResult<Target> | EmptyObject, Context>;\n/**\n * Detect click / tap and hold event\n *\n * @param callback <p>\n *   Function to call when long press event is detected\n *   (click or tap lasts for <i>threshold</i> amount of time or longer)\n *   </p>\n * @param options <ul>\n * <li><b>threshold</b>\n * - Period of time that must elapse after detecting click or tap in order to trigger <i>callback</i></li>\n * <li><b>captureEvent</b>\n * - If React Event will be supplied as first argument to all callbacks</li>\n * <li><b>detect</b>\n * - Which type of events should be detected ('mouse' | 'touch' | 'both' )\n * <li><b>cancelOnMovement</b>\n * - <p>If long press should be canceled on mouse / touch move.</p>\n * <p>You can use this option to turn it on / off or set specific move tolerance as follows:</p>\n * <ol><li><i>true</i> or <i>false</i> (by default) - when set to true tolerance value will default to <i>25px</i>\n * <li><i>number</i> - set a specific tolerance value (square size inside which movement won't cancel long press)</li></ol>\n * </li>\n * <li><b>onStart</b>\n * - Called right after detecting click / tap event (e.g. onMouseDown or onTouchStart)\n * <li><b>onFinish</b>\n * - Called (if long press <u>was triggered</u>)\n * on releasing click or tap (e.g. onMouseUp, onMouseLeave or onTouchEnd)\n * <li><b>onCancel</b>\n * - Called (if long press <u>was <b>not</b> triggered</u>)\n * on releasing click or tap (e.g. onMouseUp, onMouseLeave or onTouchEnd)\n * </ul>\n */\nexport function useLongPress<\n  Target extends Element = Element,\n  Callback extends LongPressCallback<Target, Context> = LongPressCallback<Target>,\n  Context = undefined\n>(\n  callback: Callback | null,\n  {\n    threshold = 400,\n    captureEvent = false,\n    detect = LongPressDetectEvents.BOTH,\n    cancelOnMovement = false,\n    filterEvents,\n    onStart,\n    onMove,\n    onFinish,\n    onCancel,\n  }: LongPressOptions<Target, Context> = {}\n): CallableContextResult<LongPressResult<Target, typeof detect> | Record<string, never>, Context> {\n  const isLongPressActive = useRef(false);\n  const isPressed = useRef(false);\n  const timer = useRef<NodeJS.Timeout>();\n  const savedCallback = useRef(callback);\n  const startPosition = useRef<Coordinates>(null);\n\n  const start = useCallback(\n    (context?: Context) => (event: LongPressEvent<Target>) => {\n      // Prevent multiple start triggers\n      if (isPressed.current) {\n        return;\n      }\n\n      // Ignore events other than mouse and touch\n      if (!isMouseEvent(event) && !isTouchEvent(event)) {\n        return;\n      }\n\n      // If we don't want all events to trigger long press and provided event is filtered out\n      if (filterEvents !== undefined && !filterEvents(event)) {\n        return;\n      }\n\n      startPosition.current = getCurrentPosition(event);\n\n      if (captureEvent) {\n        event.persist();\n      }\n\n      const meta: LongPressCallbackMeta<Context> = context === undefined ? {} : { context };\n\n      // When touched trigger onStart and start timer\n      onStart?.(event, meta);\n      isPressed.current = true;\n      timer.current = setTimeout(() => {\n        if (savedCallback.current) {\n          savedCallback.current(event, meta);\n          isLongPressActive.current = true;\n        }\n      }, threshold);\n    },\n    [captureEvent, filterEvents, onStart, threshold]\n  );\n\n  const cancel = useCallback(\n    (context?: Context, reason?: LongPressEventReason) => (event: LongPressEvent<Target>) => {\n      // Ignore events other than mouse and touch\n      if (!isMouseEvent(event) && !isTouchEvent(event)) {\n        return;\n      }\n\n      startPosition.current = null;\n\n      if (captureEvent) {\n        event.persist();\n      }\n\n      const meta: LongPressCallbackMeta<Context> = context === undefined ? {} : { context };\n\n      // Trigger onFinish callback only if timer was active\n      if (isLongPressActive.current) {\n        onFinish?.(event, meta);\n      } else if (isPressed.current) {\n        // Otherwise, if not active trigger onCancel\n        onCancel?.(event, { ...meta, reason: reason ?? LongPressEventReason.CANCELED_BY_TIMEOUT });\n      }\n      isLongPressActive.current = false;\n      isPressed.current = false;\n      timer.current !== undefined && clearTimeout(timer.current);\n    },\n    [captureEvent, onFinish, onCancel]\n  );\n\n  const handleMove = useCallback(\n    (context?: Context) => (event: LongPressEvent<Target>) => {\n      onMove?.(event, { context });\n      if (cancelOnMovement && startPosition.current) {\n        const currentPosition = getCurrentPosition(event);\n        /* istanbul ignore else */\n        if (currentPosition) {\n          const moveThreshold = cancelOnMovement === true ? 25 : cancelOnMovement;\n          const movedDistance = {\n            x: Math.abs(currentPosition.x - startPosition.current.x),\n            y: Math.abs(currentPosition.y - startPosition.current.y),\n          };\n\n          // If moved outside move tolerance box then cancel long press\n          if (movedDistance.x > moveThreshold || movedDistance.y > moveThreshold) {\n            cancel(context, LongPressEventReason.CANCELED_BY_MOVEMENT)(event);\n          }\n        }\n      }\n    },\n    [cancel, cancelOnMovement, onMove]\n  );\n\n  useEffect(\n    () => (): void => {\n      // Clear timeout on unmount\n      timer.current !== undefined && clearTimeout(timer.current);\n    },\n    []\n  );\n\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n\n  return useMemo(() => {\n    function result(context?: Context) {\n      const mouseHandlers = {\n        onMouseDown: start(context) as MouseEventHandler<Target>,\n        onMouseMove: handleMove(context) as MouseEventHandler<Target>,\n        onMouseUp: cancel(context) as MouseEventHandler<Target>,\n        onMouseLeave: cancel(context) as MouseEventHandler<Target>,\n      };\n\n      const touchHandlers = {\n        onTouchStart: start(context) as TouchEventHandler<Target>,\n        onTouchMove: handleMove(context) as TouchEventHandler<Target>,\n        onTouchEnd: cancel(context) as TouchEventHandler<Target>,\n      };\n\n      if (callback === null) {\n        return {};\n      }\n\n      if (detect === LongPressDetectEvents.MOUSE) {\n        return mouseHandlers;\n      }\n\n      if (detect === LongPressDetectEvents.TOUCH) {\n        return touchHandlers;\n      }\n\n      return { ...mouseHandlers, ...touchHandlers };\n    }\n\n    return result;\n  }, [callback, cancel, detect, handleMove, start]);\n}\n\n// Export all typings\nexport * from './types';\n"],"names":["LongPressEventReason","LongPressDetectEvents","isTouchEvent","event","nativeEvent","window","TouchEvent","isMouseEvent","MouseEvent","getCurrentPosition","x","touches","pageX","y","pageY","callback","threshold","captureEvent","detect","BOTH","cancelOnMovement","filterEvents","onStart","onMove","onFinish","onCancel","isLongPressActive","useRef","isPressed","timer","savedCallback","startPosition","start","useCallback","context","current","undefined","persist","meta","setTimeout","cancel","reason","CANCELED_BY_TIMEOUT","clearTimeout","handleMove","currentPosition","moveThreshold","movedDistance","Math","abs","CANCELED_BY_MOVEMENT","useEffect","useMemo","mouseHandlers","onMouseDown","onMouseMove","onMouseUp","onMouseLeave","touchHandlers","onTouchStart","onTouchMove","onTouchEnd","MOUSE","TOUCH"],"mappings":"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"}